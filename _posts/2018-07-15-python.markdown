---
layout: post
title:  python协程的另一些笔记
category: python
tag : python
--- 

### yield from

yield from是python3.3的新语法, 来自[PEP-380](https://www.python.org/dev/peps/pep-0380/), 目的也很直接:  

`for a generator to delegate part of its operations to another generator`

如果有仔细看上一篇里Beazley的那个ppt, 里面说了很多把coroutines当作pipelines管道来利用的例子, 中间作为管道的coroutines也可以说是所谓委派生成器。 在生成器gen中使用yield from subgen()时, subgen()会获得控制权, 把产出的值传给gen的调用方, 也就是调用方可以直接控制subgen。  

一个简单例子:  

```
def gen():
	for c in 'ab':
		yield c
	for i in range(0,5):
		yield i

print(list(gen()))

def gen1():
	yield from 'ab'
	yield from range(0,5)

print(list(gen1()))

output:
['a', 'b', 0, 1, 2, 3, 4]
['a', 'b', 0, 1, 2, 3, 4]

```
用yield from简化之前需要for循环处理的子生成器调用, yield会打开双向通道, 把外层的调用于内层子生成器连接起来。 其实这个例子还不太典型, 这里如果不用yield from, 我们也就仅仅需要多写一个for循环来处理简单的子生成器。然而真实使用时, 我们要处理coroutine的各种方法, send(), throw(), exit()等等, 全部手动处理的话, 代码是这样的:  

```
_i = iter(EXPR)
try:
    _y = next(_i)
except StopIteration as _e:
    _r = _e.value
else:
    while 1:
        try:
            _s = yield _y
        except GeneratorExit as _e:
            try:
                _m = _i.close
            except AttributeError:
                pass
            else:
                _m()
            raise _e
        except BaseException as _e:
            _x = sys.exc_info()
            try:
                _m = _i.throw
            except AttributeError:
                raise _e
            else:
                try:
                    _y = _m(*_x)
                except StopIteration as _e:
                    _r = _e.value
                    break
        else:
            try:
                if _s is None:
                    _y = next(_i)
                else:
                    _y = _i.send(_s)
            except StopIteration as _e:
                _r = _e.value
                break
RESULT = _r

```

使用yield from的话:  

```
RESULT = yield from EXPR

```

yield from处理了所有需要考虑的情况, 我们只需要按要求使用就可以了, 这里再列个例子:  

```
# Example of flattening a nested sequence using subgenerators

from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]

# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x, end=' ')

items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
for x in flatten(items):
    print(x, end=' ')
    
output:
1 2 3 4 5 6 7 8 Dave Paula Thomas Lewis

```

书里也明确的给出了yield from 处理的细节(p398), 我抄在这里作为记录:  
* 子生成器产出的值都直接传给委派生成器的调用方  
* 使用send()方法发给委派生成器的值都直接传给子生成器。如果发送的值是None, 那么会调用子生成器的 \__next__()方法。如果发送的值不是None, 那么会调用子生成器的send()方法。如果调用的方法抛出StopIteration异常, 那么委派生成器恢复运行。任何其他异常都会向上冒泡, 传给委派生成器  
* 生成器退出时, 生成器(或子生成器)中的return expr 表达式会触发 StopIteration(expr)异常抛出  
* yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数  
* 传入委派生成器的异常, 除了GeneratorExit之外都传给子生成器的throw()方法。如果调用throw()方法时抛出StopIteration异常, 委派生成器恢复运行。StopIteration之外的异常会向上冒泡。传给委派生成器  
* 如果把GeneratorExit异常传入委派生成器, 或者在委派生成器上调用close()方法, 那么在子生成器上调用close()方法, 如果他有的话。如果调用close()方法导致异常抛出, 那么异常会向上冒泡, 传给委派生成器, 否则, 委派生成器抛出GeneratorExit异常  

这大致就是yield from的内容了, 其实如果有所了解能看出他完成了类似其他语言await的作用, 那么为什么不直接用await?, 我猜当时应该是有过讨论的, 而且是蛮激烈的讨论, 最终可能是BDFL决定不使用新的关键字而是用yield from, 这在很长一段时期内导致def关键字的混用, 协程, 函数, 生成器都用def来定义, 对于初学者很容易困惑(比如说我)。 

因为这个原因python3.4提供了@asyncio.coroutine来装饰使用yeld from语法的协程, 便于从一个普通函数中把协程"凸显"出来。  

手册上的说明:  
>@asyncio.coroutine: Decorator to mark generator-based coroutines. This enables the generator use yield from to call async def coroutines, and also enables the generator to be called by async def coroutines, for instance using an await expression.

更巧合的是python的协程包asyncio基本完成于python3.4, 这也导致lib代码里使用了大量的yield from, 一直使用到现在, 但其实yield from在python3.5之后就被await关键字取代了。  

《流畅的python》这本书完成于2015年, 在那个时间前后, python3.5新加入了关键字asnyc/await来取代旧的yield from, [PEP-492](https://www.python.org/dev/peps/pep-0492/#async-await)里有详细的说明, 书中作者多次提到了新语法的动向, 也对yield from语法颇有微词, 原话是:"The introduction of yield from is particularly worrying"(p415), 但是不管怎么样今天的python已经可以完美使用async/await来实现协程了。

PEP-492的内容, 简单说就是用async替换掉@asyncio.coroutine, 用await替换掉yield from  
原先这样实现的协程:  

```
@asyncio.coroutine
def do(x):
	yield from asyncio.sleep(x)
	print('waiting : {}'.format(x))
	return x 
```
现在这样写:  

```
async def do(x):
	await asyncio.sleep(x)
	print('waiting : {}'.format(x))
	return x
```

PEP-492也给出官方认为的替换理由:  
* 因为使用相同的语法, coroutines跟一般的生成器太容易混淆了, 尤其是对新手 
* 特征非常不明显, 重构容易出错    
* 语法上只有允许yield的地方才可以使用异步调用, 像with或者for这样的语法压根没得用了  

另外为了严格的作出区分, PEP-492引入了新的类型coroutine, 按照他的说法就是, 强调如果用新语法就都用新语法, 新的coroutine调用里不能出现yield from的旧内容了。 其他详细内容可以自行去看, 其实对于后面的人来说yield from的内容不了解也没什么问题, 但是这确实是python协程发展中值得记录的一段"弯路"。  




