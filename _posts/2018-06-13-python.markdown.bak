---
layout: post
title:  asyncio的一些笔记
category: python
tag : python
--- 

借助流畅的python这本书, 重新学习了python有关于异步编程这一块的内容, 重点也就是asyncio这个lib, asyncio从体量上来说应该是python中比较大的标准库。 

python协程大致发展了三个阶段:  
>利用生成器的yield generator  
>引入@asyncio.coroutine与yield from[PEP-380](https://legacy.python.org/dev/peps/pep-0380/)  
>到python 3.5单独给出了协程关键字async, await, [PEP-492](https://www.python.org/dev/peps/pep-0492/), 相当于彻底区分了协程与生成器  

### yield  

yield是在python2中就被添加的语法, 在python函数中使用了yield 关键字, 那么该函数即被定义为生成器函数, 调用其会返回一个生成器对象。

生成器对象可以调用方法.send(...)发送数据, 发送的数据即为生成器中yield表达式的值, .throw(...)抛出异常, .close()终止生成器, 生成器使用前需要被预激, next(gen)或者.send(None)可以做到  

```
def gen(a):
	print('gen start')
	b = yield a
	print('received : {}'.format(b))


g = gen(1)
print(next(g))
# print(g.send(None))
print(g.send(2))



output:
gen start
1
received : 2
Traceback (most recent call last):
  File "coro.py", line 11, in <module>
    print(g.send(2))
StopIteration

```

这里写了一个超简的示例, gen()就是一个生成器函数, g是一个生成器对象, 从next()预激开始执行, 当流程被执行结束之后, 如果再对生成器调用send(...)方法, 会返回StopIteration, 这里我们可以看到一些生成器执行的特点, 每次在yield处返回给调用函数, 而调用函数send给生成器value, 请注意每次执行暂停的地方, 可以说是yield这条语句的中间, 这是需要明确理解的, 所以如果我们注释掉   
```
print(g.send(2))  
```

output会变化为:  

```
gen start
1
```
代码执行到yield a就暂停等待下一步调用了, 这时我们调用g.send(2), 会执行这里前一段代码b = yield... 是生成器获得b的值  

yield是关键的一步, 代表了产出值与让出当前控制的含义, 这是协程能够实现的关键, yield语法给python提供了在用户态调度的办法。 我们知道传统的多进程或者多线程的处理方法, 都要陷入系统调用, 不可避免的要进行上下文切换, 这是多线程下并发限制的地方。 而单线程下的协程运作是在用户态做调度, 从而可以实现更大的并发  

### yield from
python3.3经由[PEP-380](https://legacy.python.org/dev/peps/pep-0380/)引入了yield from的语法, 说实话最初看这个东西看的有点迷, 感觉还是没有找到痛点, 所以就先去找

 






