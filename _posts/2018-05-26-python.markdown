---
layout: post
title: 引用计数的一些笔记
category: python
tag : python
--- 

#### 引用计数

读到了一篇关于python垃圾回收的文章, 是跟php垃圾回收机制一样都是引用计数, 包括使用双向链表作为数据结构, 其实这个概念也很好懂, 只不过当时看php的解释时, 没弄清楚对循环引用的处理, 这次算是清楚了  

我们知道在引用计数的机制下, 一般简单类型会被直接回收掉, 这里就不说了, 问题出在循环引用也就是python中的list, tuble, dict这种结构, 比如:  

```
l = []
l.append(l)
del(l)
```
del之后的l, 按照我们代码的希望的他应该是属于垃圾要被回收掉的资源, 然而在这里因为他的引用计数仍旧是1, l并不会被释放  

当然啦, 处理他们并不复杂, python会记录所用的容器对象到一个双向链表, 然后对这个列表内的对象依次检查:  
>1. 对每个对象的引用次数计作refs  
>2. 对每个对象, 找到它引用的其他对象并把他们的refs减去1  
>3. 所有refs大于1的对象是被外部对象集合所引用的对象, 不能释放。 这一类对象所引用到的对象也不能释放  
>4. 除此之外目前剩余的对象就是我们已经无法在python代码再利用的对象了, 可以释放掉这些资源  

回过头来再看php垃圾回收处理循环引用的办法, 还是看得出有区别的, 首先php只对那些ref减少但不减少为0的对象做记录, 之后对这些对象中的每个元素做zval(php所采用的计数符号)减1, 之后如果发现对象本身的zval变成了0, 那么就可以说这个zval是一个可以回收的垃圾了  

这里就是官网所记载的版本, 比对一下python的回收机制来看, 貌似php漏掉了一部分内容, 漏掉了减过之后refs为1的某些对象, 但是我们仔细分析一下, 这些对象内部所有的引用都被减掉了, 也就是说如果他们有对自身的引用, 也会在这里被减掉了, 所以他们只能是被外部引用, 也契合了上面第三步的后半句--属于被其他对象所引用的对象, 所以看似漏掉了但是实际上这部分是不属于垃圾的  
