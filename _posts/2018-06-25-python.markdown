---
layout: post
title:  yield的一些笔记
category: python
tag : python
--- 
 
### 前言  

最近一直在看fluent python, 这本书里很详细的描述了python coroutine的相关信息, 从yield一直到aiohttp, 跨越了python2.2到python3.5。   

python协程大致发展了数个阶段:  

>[PEP-255](https://www.python.org/dev/peps/pep-0255/), python2.2引入yield关键字来创建生成器    
>[PEP-342](https://www.python.org/dev/peps/pep-0342/), python2.5增强了yield generator的功能, 使之可以作为协程    
>[PEP-380](https://legacy.python.org/dev/peps/pep-0380/), python3.4引入@asyncio.coroutine与yield from      
>[PEP-492](https://www.python.org/dev/peps/pep-0492/), python3.5单独给出了协程关键字async/await, 相当于彻底区分了协程与生成器  

### yield  

先从yield说起。[PEP-255]((https://www.python.org/dev/peps/pep-0255/))建立的时间是18-May-2001(卧槽我那会应该才小学3年级), 这个PEP提出了新的关键字yield, 使用yield关键字的函数即为生成器函数, 除了PEP中提到的那些动机, 对迭代器的改进和提升最为明显, PEP中这样描述:  

`provide a kind of function that can return an intermediate result ("the next value") to its caller, but maintaining the function's local state so that the function can be resumed again right where it left off`  

相比迭代器直接在内存中生成本次迭代的所有数据, 生成器每次只返回一个结果(the next value), 然后会维持当前的函数的相关上下文直到再次被调用(resumed)。因为不是一次得到整个迭代序列, 所以对内存的需求很低, 可以用来迭代较大的对象乃至无限长数列(python3中 range已经改用生成器实现)。如果我们把迭代器模型看成一个消费者/生产者模型, 那么这里的生产者只是在按次序给出下一个值。放到生成器这里, 我们可以更精细的控制生产者的产出。 

```
def fib():
    a, b = 0, 1
    while True:
       yield b
       a, b = b, a+b

f = fib()
for i in range(100):
	print(next(f))

```  

这里是一段利用生成器产生斐波那契数列的程序, fib是一个生成器函数, 调用fib不会执行其内部的代码, 而是会产生一个生成器对象f, f是一个可迭代对象, 对f调用next()方法, 生成器开始执行, 直到遇到下一个yield或者return语句时中断, 产出结果并交出控制权给调用函数。  

可以看到这个阶段, 生成器的功能还比较简陋, 调用方式只有next(), return不能返回值而是抛出StopIteration异常, 只能产出值而不能接收值。

### enhanced generators  



