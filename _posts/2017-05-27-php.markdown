---
layout: post
title: 测试了一次hash碰撞攻击
category: php
tag : php
---

前段时间看新闻说, 有人找到了两个pdf文件得到了相同的SHA1值, 想想以前上课密码学的时候对hash真的很有兴趣, 趁现在看源码 顺便看一下php的hash, 上次就说了hash表在php中的地位非常高  

大家也都知道hash表处理得当的话, 插入和查找是只有O(1)的, 但是这种得当现实并不会有, 只要是hash表就一定会产生碰撞冲突, php这里用链表来存放产生的冲突值, 在最坏情况下, 就会从这样:  

<img src="/img/in-post/hash.png">

变成这样:  

<img src="/img/in-post/hash1.png">  

退化成了一个链表, 查找变成了O(N), 如果你伪造一段数据来针对性的存储成这种链表的结构, 会成功的构造一次碰撞攻击  

首先说明 php的hashtable大小都是2的指数, 也就是说php会修正这个size到2^n, 比如如果你存入11个元素的数组, 那么数组实际大小是16, 如果存入60个话, 实际大小为64 当你的存入的元素个数大于了数组目前的最多元素个数的时候, php会对这个数组进行扩容, 然后重新hash  

```
ht-TableMask = ht-TableSize - 1;
```
>php中用的掩码是直接用size-1, 当有key传入时, 如果是整型就会直接和TableMask按位与来得到最终的hash index, 如果是string则会用我上篇说的那个djb算法来的整型的key, 再去按位与得到hash index

根据这些我们可以构造一个size 为2^16的哈希表, 二进制表示为:  
```
1 0000 0000 0000 0000
```
其码表是:  
```
0 1111 1111 1111 1111  
```

好了 我们可以构造任何数据, 只要保证他的后16位都为0 就可以与出来最后值为0的hash index  

*10 0000 0000 0000 0000 & 0 1111 1111 1111 1111 = 0*  
*11 0000 0000 0000 0000 & 0 1111 1111 1111 1111 = 0*  

具体代码如下:  

<img src="/img/in-post/hash2.png">  

```
array size 65536
7.4058902263641 seconds
```
版本php7.0.4, 执行了7s多才结束  

<img src="/img/in-post/hash3.png">  

>疯狂占用cpu资源  

这样就完成了一次hash碰撞攻击, 5.4的php版本 通过控制input数量来做了一些控制, 但是貌似没有从数据结构上处理了这个hash碰撞问题, 现在版本已经来到了7.0, 仍旧在代码层面是可以碰撞的  



