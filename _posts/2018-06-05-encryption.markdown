---
layout: post
title: RSA 的一些笔记
category: encryption
tag : encryption
---

### RSA

昨天看帖子又看了一篇介绍RSA的, 想起不久之前记过一篇Diffie-Hellman, 顺手再记一篇。 RSA作为一种非对称加密算法, 用处非常多, 比如跟Diffie-Hellman一样作为密钥传递(key exchange)的手段, 当然本身他作为加密手段已经可以用来传递明文了, 还可以把public/private key反用来做消息签名。

当然, 这个话题很大, 能说很多, 这里只是简单说一下我理解的原理, 之前说Diffie-Hellman key exchange的时候, 我们说这个算法依赖于计算离散对数的难度, 要求用到的质数要大, RSA同样有类似的要求, 要求有两个大的质数, 因为两个大的质数相乘容易, 但对其结果进行分解是极难的, 这个性质是该算法立足的根基。  

我们先用两个比较小的质数演示  


比如:  
11,19  
求出 :  
n = 11 * 19 = 209, m = (11 - 1) * (19 - 1) = 180  
通过两个质数得到的m, n有一个规律, 任意数a的i次方 mod n, i会以m为间隔而形成一个周期     
比如 :  
2 mod 209, 2^181 mod 209, 2^361 mod 209  
这些结果都还是2  
用a来表示 :  
a, a^(m+1), a^(2m+1), a^(3m+1) ...  
对于209的余数都相同为2    
有了这个m为间隔的周期规律, 我们进行下一步, 我们用另外两个数b, c, 使得 :  
b * c mod m = 1  
假a是我们的明文, b, c做key, 加密过程 :  
a^b  
解密过程:  
a^b^c = a^(b*c)  
这个结果去mod n(例子这里也就是209这个数)就等于a, 这样就完成了整个加密解密的过程, 而b和c就分别作为公钥跟私钥出现  

接下来我们需要一个求出b,c 的方法, 先找到一个b, 使其与m互质, 观察7 是这样一个数字, 接下来按照 :  
b * c mod m = 1  
这个公式, 找出一个符合条件的c, 这里 :  
721/7 = 103  
是一个符合条件的数, 假设我们要加密的数字是20, 那么密文就是 :  
20^7 mod 209 = 191  
解密 :  
191^103 mod 209 = 20  

上面这个例子, 用两个我们可以通过简单计算就证明的质数模拟了这个算法的过程, 而实际中为了加密的有效性, 不会使用类似简单的数字  

我们知道公钥是人人都可以知道的, 相当于知道(b,n), 要想知道私钥(c,n), 可以很简单的通过 b * c mod m = 1来得到c, 但是这里m是私有的, 外部只能通过分解n来得到m, 在这里n是209, 分解因数得到19跟11可以快速计算出m, 但是如果我们用两个大位数的质数(实际应用时应该是上千位的质数)来相乘得到n, 那么乘出来的数就很难被分解了    

这基本就是公钥私玥的整个算法思路的一个过程, 中间一些公式的推导我按照自己理解写成大白话了, 感觉这样理解起来方便一些 
